# server.py
from flask import Flask, Response, request
from flask_socketio import SocketIO, emit
import requests
import re

app = Flask(__name__)
app.config['SECRET_KEY'] = 'daria_local_secure_key_please_change'
socketio = SocketIO(app, cors_allowed_origins="*")

# URLs - change if needed
HTML_URL = 'https://raw.githubusercontent.com/amiirkebir-hue/HTMI/refs/heads/main/DAI'
USERLIST_URL = 'https://raw.githubusercontent.com/amiirkebir-hue/HTMI/refs/heads/main/username'

# mapping of socket id -> username
sid_to_user = {}
online_users = set()

def fetch_user_pairs():
    """
    Fetch username:password pairs from your GitHub raw file.
    Returns dict {username: password}
    """
    try:
        r = requests.get(USERLIST_URL, timeout=5)
        r.raise_for_status()
        text = r.text
        pairs = {}
        for line in text.splitlines():
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            # accept "user:pass" or "user : pass"
            m = re.split(r'\s*:\s*', line, maxsplit=1)
            if len(m) == 2:
                user, pwd = m[0].strip(), m[1].strip()
                if user:
                    pairs[user] = pwd
        return pairs
    except Exception as e:
        print("Failed to fetch user list:", e)
        return {}

def inject_auth_and_client(html_text):
    """
    Inject login UI, client-side auth, avatar and socket logic into fetched HTML.
    We insert before </body>.
    """
    injection = r"""
<!-- DariaChat: injected login + client script (English) -->
<style>
/* login overlay */
#loginOverlay{
  position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
  background: rgba(13,13,43,0.75); z-index:9999;
}
.loginCard{
  background:#fff; padding:22px; border-radius:12px; width:360px; box-shadow:0 8px 30px rgba(0,0,0,0.35);
  font-family: "Segoe UI", sans-serif; color:#111;
}
.loginCard h2{margin:0 0 10px 0}
.loginCard input{width:100%; padding:10px; margin:8px 0; border-radius:8px; border:1px solid #ddd}
.loginCard button{width:100%; padding:10px; border-radius:8px; border:none; background:#5a60ff; color:white; cursor:pointer}
.topProfile{
  position: absolute; right: 18px; top: 12px; display:flex; align-items:center; gap:8px; z-index:5000;
}
.topProfile img{width:40px; height:40px; border-radius:50%; object-fit:cover; border:2px solid #fff}
.topProfile .name{background: rgba(255,255,255,0.85); padding:6px 10px; border-radius:10px; font-size:14px}
.message.you{ background:#d0e6ff; align-self:flex-end; color:#022; }
.message.other{ background:#ececff; align-self:flex-start; color:#111; }
.msgRow{ display:flex; gap:10px; align-items:flex-end; margin:6px 0; }
.msgAvatar{ width:36px; height:36px; border-radius:50%; object-fit:cover; }
.msgBubble{ padding:8px 12px; border-radius:12px; max-width:65%; word-wrap:break-word; }
</style>

<div id="loginOverlay">
  <div class="loginCard" id="loginCard">
    <h2>Daria Local â€” Login</h2>
    <input id="login_username" placeholder="Username" autocomplete="off">
    <input id="login_password" placeholder="Password" type="password" autocomplete="off">
    <div style="display:flex; gap:8px; margin-top:8px;">
      <button id="btnLogin">Login</button>
    </div>
    <p id="login_msg" style="margin-top:10px;color:#c33"></p>
    <p style="font-size:12px;color:#666;margin-top:8px">User credentials are read from the repository file (read-only).</p>
  </div>
</div>

<div class="topProfile" id="topProfile" style="display:none;">
  <img id="topAvatar" src="" alt="avatar">
  <div class="name" id="topName"></div>
</div>

<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
<script>
(() => {
  // config
  const LOGIN_URL = '/api/login';
  // helpers
  const $ = id => document.getElementById(id);

  // localStorage keys
  const LS_USER = 'daria_user';
  const LS_AVATAR = 'daria_avatar'; // base64 data url

  // elements
  const overlay = $('loginOverlay');
  const loginMsg = $('login_msg');
  const btnLogin = $('btnLogin');

  // check if already logged in in localStorage
  let storedUser = localStorage.getItem(LS_USER);
  if (storedUser) {
    // we still validate server-side to be safe
    attemptAutoLogin(storedUser);
  }

  btnLogin.onclick = () => {
    const user = $('login_username').value.trim();
    const pass = $('login_password').value;
    if (!user || !pass) { loginMsg.textContent = 'Please enter username and password.'; return; }
    fetch(LOGIN_URL, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({username: user, password: pass})
    }).then(r => r.json()).then(j => {
      if (j && j.status === 'ok') {
        localStorage.setItem(LS_USER, user);
        loginMsg.style.color = 'green';
        loginMsg.textContent = 'Login successful. Preparing chat...';
        setTimeout(() => startChat(user), 600);
      } else {
        loginMsg.style.color = '#c33';
        loginMsg.textContent = j && j.message ? j.message : 'Login failed';
      }
    }).catch(e => {
      loginMsg.style.color = '#c33';
      loginMsg.textContent = 'Login error: ' + e;
    });
  };

  function attemptAutoLogin(user){
    // try to login with empty password to check? better ask server to just validate existence
    fetch(LOGIN_URL, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({username: user, password: '__local_check__'})
    }).then(r => r.json()).then(j => {
      if (j && j.status === 'ok') startChat(user);
      else {
        // clear stored user if not valid
        localStorage.removeItem(LS_USER);
        overlay.style.display = 'flex';
      }
    }).catch(_=>{
      overlay.style.display = 'flex';
    });
  }

  // chat state
  let socket = null;
  let currentUser = null;

  function startChat(user){
    currentUser = user;
    overlay.style.display = 'none';

    // show profile area
    const top = $('topProfile'); const topName = $('topName'); const topAvatar = $('topAvatar');
    top.style.display = 'flex';
    topName.textContent = currentUser;

    // load avatar from localStorage or ask user to upload
    let avatarData = localStorage.getItem(LS_AVATAR);
    if (!avatarData) {
      // ask user to pick avatar (file input)
      const inp = document.createElement('input');
      inp.type = 'file'; inp.accept = 'image/*';
      inp.onchange = () => {
        const f = inp.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = e => {
          const dataUrl = e.target.result;
          localStorage.setItem(LS_AVATAR, dataUrl);
          topAvatar.src = dataUrl;
          avatarData = dataUrl;
        };
        reader.readAsDataURL(f);
      };
      // prompt once
      inp.click();
    } else {
      topAvatar.src = avatarData;
    }

    // allow clicking avatar to change
    $('topProfile').onclick = () => {
      const inp = document.createElement('input');
      inp.type = 'file'; inp.accept = 'image/*';
      inp.onchange = () => {
        const f = inp.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = e => {
          const dataUrl = e.target.result;
          localStorage.setItem(LS_AVATAR, dataUrl);
          topAvatar.src = dataUrl;
        };
        reader.readAsDataURL(f);
      };
      inp.click();
    };

    // connect socket
    socket = io();

    socket.on('connect', () => {
      // tell server who we are
      socket.emit('join', currentUser);
    });

    socket.on('user_list', list => {
      // update top UI user count (or wherever)
      const cntEl = document.querySelector('#user_count');
      if (cntEl) cntEl.textContent = list.length;
    });

    socket.on('receive_message', obj => {
      // obj: { username, avatar, text }
      renderMessage(obj);
    });

    // wire send button and enter key
    const sendBtn = document.querySelector('#send');
    const msgInput = document.querySelector('#message');
    sendBtn && sendBtn.addEventListener('click', sendMessage);
    msgInput && msgInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendMessage(); });

    function sendMessage(){
      const txt = msgInput.value.trim();
      if (!txt) return;
      const avatar = localStorage.getItem(LS_AVATAR) || '';
      socket.emit('send_message', { username: currentUser, avatar: avatar, text: txt });
      msgInput.value = '';
    }

    // expose render for existing messages
    function renderMessage(obj){
      const messages = document.querySelector('#messages');
      if (!messages) return;
      const row = document.createElement('div');
      row.className = 'msgRow';

      const isMe = obj.username === currentUser;

      if (!isMe){
        // avatar left
        const img = document.createElement('img');
        img.className = 'msgAvatar';
        img.src = obj.avatar || '';
        row.appendChild(img);
        const bubble = document.createElement('div');
        bubble.className = 'msgBubble message other';
        bubble.textContent = obj.username + ': ' + obj.text;
        row.appendChild(bubble);
      } else {
        // my message: bubble first then avatar on right
        const bubble = document.createElement('div');
        bubble.className = 'msgBubble message you';
        bubble.textContent = 'You: ' + obj.text;
        row.appendChild(bubble);
        const img = document.createElement('img');
        img.className = 'msgAvatar';
        img.src = obj.avatar || '';
        row.appendChild(img);
        row.style.justifyContent = 'flex-end';
      }

      messages.appendChild(row);
      messages.scrollTop = messages.scrollHeight;
    }
  }
})();
</script>
<!-- end injection -->
"""
    # insert before closing </body>
    if '</body>' in html_text:
        return html_text.replace('</body>', injection + '\n</body>', 1)
    else:
        return html_text + injection

@app.route('/api/login', methods=['POST'])
def api_login():
    data = request.get_json(force=True)
    username = (data.get('username') or '').strip()
    password = data.get('password') or ''
    # fetch list from github
    pairs = fetch_user_pairs()
    if username in pairs and pairs[username] == password:
        return {"status": "ok", "message": "Login successful"}
    # Some clients use '__local_check__' to validate existence without password; allow that if username exists
    if password == '__local_check__' and username in pairs:
        return {"status": "ok", "message": "User exists"}
    return {"status": "error", "message": "Invalid username or password"}

@app.route('/')
def index():
    try:
        r = requests.get(HTML_URL, timeout=5)
        r.raise_for_status()
        html = r.text
    except Exception as e:
        # fallback simple page if template can't be fetched
        html = """
        <!doctype html><html><head><meta charset="utf-8"><title>Daria Local</title></head>
        <body><h2>Could not load remote template. Falling back to default UI.</h2><div id="chat"></div></body></html>
        """
    injected = inject_auth_and_client(html)
    return Response(injected, mimetype='text/html')

# Socket handlers
@socketio.on('join')
def on_join(username):
    sid = request.sid
    sid_to_user[sid] = username
    online_users.add(username)
    emit('user_list', list(online_users), broadcast=True)
    print(f"{username} joined (sid={sid})")

@socketio.on('disconnect')
def on_disconnect():
    sid = request.sid
    username = sid_to_user.get(sid)
    if username:
        online_users.discard(username)
        sid_to_user.pop(sid, None)
        emit('user_list', list(online_users), broadcast=True)
        print(f"{username} disconnected (sid={sid})")

@socketio.on('send_message')
def on_message(obj):
    # obj expected: { username, avatar, text }
    username = obj.get('username', 'Unknown')
    text = obj.get('text', '')
    avatar = obj.get('avatar', '')
    # broadcast the whole object
    emit('receive_message', {'username': username, 'avatar': avatar, 'text': text}, broadcast=True)

if __name__ == '__main__':
    socketio.run(app, host='127.0.0.1', port=5000)
